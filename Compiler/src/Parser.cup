package compiler.parser;

import java_cup.runtime.Symbol;

class Parser;

parser code {:
 
    public void report_error(String message, Object info)
    {
        StringBuilder sb = new StringBuilder();
        sb.append("ERROR: ");
        sb.append(message).append(". ");
        
        if (info instanceof Symbol)
        {
            Symbol s = ((Symbol) info);
            sb.append("Token ").append(s.value);

            if (s.left >= 0)
            {                
                sb.append(" in line ").append(s.left);
                if (s.right >= 0)
                {
                    sb.append(", column ").append(s.right).append(".");
                }
            }
        }

        System.err.println(sb);
    }
   
    public void report_fatal_error(String message, Object info)
    {
        report_error(message, info);
        System.exit(1);    
    }

    public void syntax_error(Symbol current_token)
    {
        report_error("Syntax Error", current_token); 
    }

    public void unrecovered_syntax_error(Symbol current_token)
    {
        report_fatal_error("Couldn't repair and continue parse", current_token);
    }
    
:};

/* Terminals (tokens returned by the scanner). */

// Paréntesis.
terminal LPAREN, RPAREN, LBRACKET, RBRACKET;

// Operadores aritméticos y de asignación.
terminal PLUS, PLUS_PLUS, MINUS, MINUS_MINUS, DIV, TIMES, MOD, ASSIGNMENT, PLUS_EQUALS, MINUS_EQUALS, DIV_EQUALS, TIMES_EQUALS;

// Operadores de comparación.
terminal EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, GREATER_EQUALS_THAN, LESS_EQUALS_THAN;

// Operadores lógicos.
terminal AND, OR, XOR, NOT;

// Operadores de bit.
terminal SHIFT_LEFT, SHIFT_RIGHT, SHIFT_LEFT_EQUALS, SHIFT_RIGHT_EQUALS;

// Palabras reservadas.
terminal ARRAY, BEGIN, BOOLEAN, BYTE, CASE, CHAR, CONST, DO, DOWNTO, ELSE, END, FILE, FOR, FORWARD, FUNCTION, GOTO, IF, IN, INLINE, INT, LABEL, LONGINT, OF, PACKED, PROCEDURE, PROGRAM, READ, REAL, RECORD, REPEAT, SET, SHORTINT, STRING, THEN, TO, TYPE, UNTIL, VAR, WHILE, WITH, WRITE;

// Otros
terminal SEMI, COMMA, COLON, DOT;

// Terminales con valor.
terminal Object NIL;
terminal Integer NUMBER;
terminal Double DOUBLE;
terminal String XTRING;
terminal Character CHARACTER;
terminal String IDENTIFIER;
terminal Boolean TRUE, FALSE;

/* Non terminals */
non terminal expr, expr_num;
non terminal term;
non terminal condition_number, condition, condition_list;
non terminal identifier_list, data_type, array_data_type;
non terminal variable_declaration, array_declaration, declaration, declaration_list, declaration_block;
non terminal constant_declaration, constant_declaration_list, constant_declaration_block;
non terminal parameter, parameter_list, parameter_declaration_list, parameter_declaration, function_return, function_block, function;
non terminal procedure_block, procedure, code_block_item, code_block;
non terminal assignment_expr, function_call, sentence, sentence_item;
non terminal for_statement, while_statement, repeat_statement, if_statement, case_statement, case_list, case_item;
non terminal function_item, function_list, program;

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
precedence left AND, OR, XOR;
precedence left LPAREN, RPAREN; 

start with program;

expr ::= LPAREN expr RPAREN | expr_num;

expr_num ::= expr_num:e1 PLUS  expr_num:e2
       | expr_num:e1 MINUS expr_num:e2
       | expr_num:e1 TIMES expr_num:e2
       | expr_num:e1 DIV   expr_num:e2
       | expr_num:e1 MOD   expr_num:e2
       | MINUS expr_num:e
       | expr_num PLUS_PLUS
       | expr_num MINUS_MINUS
       | term; 

term ::= NUMBER:n
       | DOUBLE:d
       | XTRING:s
       | CHARACTER:c
       | IDENTIFIER:i
       | TRUE:t
       | FALSE:f
       | NIL:n;

condition_number ::= NUMBER:n1 GREATER_THAN NUMBER:n2
                   | NUMBER:n1 LESS_THAN NUMBER:n2
                   | NUMBER:n1 GREATER_EQUALS_THAN NUMBER:n2
                   | NUMBER:n1 LESS_EQUALS_THAN NUMBER:n2
                   | DOUBLE:d1 GREATER_THAN DOUBLE:d2
                   | DOUBLE:d1 LESS_THAN DOUBLE:d2
                   | DOUBLE:d1 GREATER_EQUALS_THAN DOUBLE:d2
                   | DOUBLE:d1 LESS_EQUALS_THAN DOUBLE:d2
                   | NUMBER:n1 GREATER_THAN DOUBLE:d2
                   | NUMBER:n1 LESS_THAN DOUBLE:d2
                   | NUMBER:n1 GREATER_EQUALS_THAN DOUBLE:d2
                   | NUMBER:n1 LESS_EQUALS_THAN DOUBLE:d2
                   | DOUBLE:d1 GREATER_THAN NUMBER:n
                   | DOUBLE:d1 LESS_THAN NUMBER:n
                   | DOUBLE:d1 GREATER_EQUALS_THAN NUMBER:n
                   | DOUBLE:d1 LESS_EQUALS_THAN NUMBER:n;

condition ::= LPAREN condition:c RPAREN
            | condition_number:cn                   
            | term:t1 EQUALS term:t2                 
            | term:t1 NOT_EQUALS term:t2              
            | TRUE:t                                   
            | FALSE:f;                          

condition_list ::= LPAREN condition_list:cl RPAREN
                 | condition_list:c1 AND condition_list:c2
                 | condition_list:c1 OR  condition_list:c2
                 | condition_list:c1 XOR condition_list:c2
                 | condition:c;                                    

identifier_list ::= identifier_list COMMA IDENTIFIER
                  | IDENTIFIER;

data_type ::= STRING | CHAR | REAL | BYTE | INT | LONGINT | SHORTINT | BOOLEAN;

array_data_type ::= CHAR | INT | LONGINT | SHORTINT;

variable_declaration  ::= identifier_list COLON data_type SEMI;

array_declaration ::= IDENTIFIER COLON ARRAY LBRACKET NUMBER DOT DOT DOT NUMBER RBRACKET OF 
                      array_data_type SEMI;

declaration ::= variable_declaration | array_declaration;

declaration_list ::= declaration_list declaration 
                   | declaration;

declaration_block ::= VAR declaration_list | /* Epsilon */ ;

constant_declaration ::= IDENTIFIER EQUALS term SEMI;

constant_declaration_list ::= constant_declaration_list constant_declaration
                            | constant_declaration;

constant_declaration_block ::= CONST constant_declaration_list  | /* Epsilon */ ;

parameter_declaration ::= data_type IDENTIFIER;

parameter_declaration_list ::= parameter_declaration_list COMMA parameter_declaration
                 | parameter_declaration;

function_return ::= IDENTIFIER ASSIGNMENT expr;

assignment_expr ::= IDENTIFIER ASSIGNMENT expr
                    | IDENTIFIER PLUS_EQUALS expr
                    | IDENTIFIER MINUS_EQUALS expr
                    | IDENTIFIER DIV_EQUALS expr
                    | IDENTIFIER TIMES_EQUALS expr;

parameter_list ::= parameter_list COMMA expr
                | expr;

function_call ::= IDENTIFIER LPAREN parameter_list RPAREN;

sentence_item ::= assignment_expr | function_call | expr;

sentence ::= sentence_item SEMI;

code_block_item ::= sentence | for_statement | while_statement | repeat_statement | if_statement | case_statement;

code_block ::= code_block code_block_item
             | code_block_item;

function_block ::= declaration_block constant_declaration_block code_block function_return;

function ::= FUNCTION IDENTIFIER LPAREN parameter_declaration_list RPAREN COLON data_type BEGIN function_block END;

procedure_block ::= declaration_block constant_declaration_block code_block;

procedure ::= PROCEDURE IDENTIFIER LPAREN parameter_declaration_list RPAREN BEGIN procedure_block END;

for_statement ::= FOR IDENTIFIER ASSIGNMENT expr TO expr DO BEGIN code_block END;

while_statement ::= WHILE condition_list DO BEGIN code_block END;

repeat_statement ::= REPEAT code_block UNTIL condition_list;

if_statement ::= IF condition_list THEN sentence ELSE sentence
                | IF condition_list THEN sentence; 

case_item ::= expr COLON sentence;

case_list ::= case_list case_item
            | case_item;

case_statement ::= CASE IDENTIFIER OF case_list ELSE sentence;

function_item ::= function | procedure;

function_list ::= function_list function_item
                | function_item
                | /* Epsilon */;

program ::= PROGRAM IDENTIFIER constant_declaration_block declaration_block function_list BEGIN code_block END;
